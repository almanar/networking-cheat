Networking protocols and applications. E.g.: TCP/IP, email, Firefox, netstat, etc.

Almost all OS specifics currently only discuss for Linux, but additions of other OSs are welcome.

#Sources

##Free

- <http://www.aboutdebian.com/network.htm>

##Non free

[ste12]: http://www.amazon.com/TCP-Illustrated-Volume-Addison-Wesley-Professional/dp/0321336313

-   [stevens - 2012 - tcp ip illustrate volume 1 2nd edition][ste12]

    Extremely clear and exemplified.

    Gives due emphasis to the key points.

    Great first book.

[dos06]: http://www.amazon.com/Understanding-TCP-IP-ebook/dp/B007TUYE0G/

-   [dostalek - 2006 - Understanding tcp ip][dos06]

    Explains the most important Internet protocol suite protocols deeply.

    Might not be the best first TCP IP book because it is a bit advanced, but it is a very good second one if you know the basics.

#OSI vs IPS

Models for network protocols.

IPS model has only 4 layers, OSI has 7.

Both seem to contain more or less the same protocols, except that they are put into different layers.

IPS is simpler to remember where each protocol goes since it has less layers.

#IPS

<http://en.wikipedia.org/wiki/Internet_protocol_suite>

##Protocols in layers

Each layer contains many protocols, each of which helps the layer achieve its functions

Some of the most common protocols in each layer are and the function of the layers are:

-   application: HTTP, HTTPS, FTP, DHPC and many more.

    Whatever protocol any application uses.

    Many protocols are standardized by large organizations, and have a specific port reserved for them on each computer.

-   transport: TCP and UDP are by far the most common

    The transport layer:

    - splits up the data for the application layer in more manageable chunks.

    - guarantees that each chunk arrived, and if not asks for it again.

-   Internet: IP is the most common

    Finds the path between any two computers even if they are not on the same network.

-   link: Ethernet, ARP

    Finds the path between two computers that are on the same network.

To get a feeling for what each layer does, learn some of the most popular protocols of each of those layers.

##Layer data structure

Each layer adds a header to the layer below containing its information:

    | application data  |
    | transport data    | transport header |
    | internet data                        | internet header |
    | link data                                              | link data  |

-   the transport data is the same as the application data.

-   the Internet data contains exactly:

    - the transport data
    - the transport header

-   the link data contains exactly:

    - the Internet data
    - the Internet header

##Example: browser fetches page

A browser wants to make a typical HTTP request to a remove server to get a web page.

It knows the IP of that server.

The browser gives to the networking system

-   the HTTP data
-   the IP of the server
-   the port on the server.

    HTTP is standardized by IANA to be accepted on port 80/TCP.

And then asks the networking system to:

- add TCP header data to the HTTP data generated by the browser to make a TCP package
- add an IP header to make an IP package.
- add an Ethernet header to make an Ethernet package.

Next the computer sends the Ethernet header to its router, which is on the same network.

The router is able to receive that data because of the information contained in the Ethernet header.

The router is now done with the Ethernet header and throws it away.

The router puts the Ethernet header...

TODO continue. Add diagrams.

#IP

Protocol that allows to:

- assign addresses to network interfaces.
- find path between one computer to another, possibly passing through many routers

##IP header

Learn what the IP header contains:

<http://en.wikipedia.org/wiki/IPv4_header#Header>

Fields by increasing interest / ease to understand ratio:

-   version (4 bits)

    Indicates the protocol version.

    Value 4 for IPv4.

-   Internet header length (IHL) (4 bits)

    Length of the IP header only (no data) in 4 byte units.

-   total length (2 bytes)

    Total length of header + body in bytes

    This must be transmitted as the length is variable.

-   IPs of destination and origin (4 bytes each)

-   time to live (TTL) (1 byte)

    Decreased whenever the packet passes through a router.

    If 0, router does not forward the package, because it has already traveled for too long, and signals this to the sender via an ICMP Time exceeded with Code = 0.

    This prevents lost packages from doing infinite turns on the network.

-   header checksum (2 bytes)

-   protocol (1 byte)

    Number that identifies the protocol contained in the IP data, for example TCP or UDP.

    In this way, the receiver knows how to interpret the data inside of the IP package.

    The numbers are assigned by IANA and can be found [here](http://en.wikipedia.org/wiki/List_of_IP_protocol_numbers).

-   flags: 3 bits

    Used for IP fragmentation.

-   fragment offset: (13 bits)

    Used for IP fragmentation.

-   identification: (2 bytes)

    Used for IP fragmentation.

##IP fragmentation

If a router will forward this packet to another interface, it may be that the MTU of the other interface be smaller than the previous one, and the package cannot be transmitted hole.

In this case, IP provides a fragmentation mechanism to split up the package into smaller ones.

TCP always attempts to avoid IP fragmentation, so that if TCP is being used, it is unlikely that fragmentation will happen. It is therefore easier to observe IP fragmentation for UDP packets.

Reassembly of fragments is meant to happen only at the final destination.

The fields used from the IP header  are:

-   flags (3 bits)

        | 0 | DF | MF |

    - 0: reserved, always set to 0

    -   `DF`: don't fragment.

        If that is the case, the router first checks the `DF` flag.

        If `DF = 1`, routers should not fragment, and notify the source via an ICMP fragmentation not possible message.

        If `DF = 0`, fragmentation can occur, and tranmission continues.

    - `MF`: more fragments

        If 0, this is the last fragment.

        If 1, there are more fragments to come.

        A common technique is to send first the last segment, which allows the destination to know how large a buffer it will need in advance.

-   fragment offset: (13 bits)

    How many 8 byte units of IP data have already been sent.

    The first fragment always has this field equal to 0.

    But if fragmentation occurs, the following fragments will contain how much IP data has been sent already.

-   identification: (2 bytes)

    It is set by the sender with a different number for each IP datagram.

    If fragmentation will occur, each fragment's IP header will get the same identification number so that they can be reassembled afterwards.

    Identification numbers can be the same across multiple source IPs,
    but for a single source IPs they are unique.

##IP address

An unique address that identifies a host, for example a separate workstation.

IPv4 addresses are 4 bytes long.

They are often noted byte by byte as:

    192.156.0.1

Each computer knows its IP address.

This can be set in two ways:

-   statically and manually: admin enters those values for each computer.

    They never change.

-   dynamically and automatically.

###IP classes

Each address has two parts: network part and host part.

####Example: network and host parts

- 2 networks
- 3 bytes for the network part
- 1 router
- 3 computers on the same network

Things could look like:

    +---------------+  +---------------+  +---------------+
    | computer 1    |  | computer 2    |  | computer 3    |
    |---------------|  |---------------|  |---------------|
    | 192.156.0.2   |  | 192.156.0.3   |  | 192.156.0.4   |
    |+--------------+  |+--------------+  |+--------------+
    ||                 ||                 ||
    |+=================++=================++
    ||
    |+---------------+
    || 192.156.0.1   |
    ||---------------+
    || router        |
    ||---------------|
    || 192.157.0.1   |
    |+---------------+
    ||
    |+=================++=================++
    ||                 ||                 ||
    |+--------------+  |+--------------+  |+--------------+
    | computer 3    |  | computer 4    |  | computer 5    |
    |---------------|  |---------------|  |---------------|
    | 192.157.0.2   |  | 192.157.0.3   |  | 192.157.0.4   |
    +---------------+  +---------------+  +---------------+


How many bytes are the network, and how many bytes are the host was determined only by the class of the IP in the past.

Each computer must know how many bytes are network and how many are host.

In the past, there were 5 IP ranges:

- A: starts with 0
- B: starts with 10
- C: starts with 110
- D: starts with 1110
- E: all others

IPs on classes A, B and C were reserved for internal use.

If your address is in those ranges, the routers proxy server knows it is an internal one you are asking about

Most common home range is the Class C:

    192.168.0.1 through 192.168.255.254
    subnet mask 255.255.255.0

###LAN IP

###Internal IP

###WAN IP

###External IP

If you use a router, your entire network has a single IP seen from the outside (WAN), and an internal IP for each interface seen on the private local network (LAN).

Get external IP:

    curl ipecho.net/plain
    curl ifconfig.me

You external IP may change or not depending on how your ISP operates. Most ISPs to modify home user's IPs from time to time to have more flexibility, but many give you the same external IP for at least several hours, making it possible for you to use it for simple development.

This only matters if you want to ha external computers make requests for you, e.g. to serve a web server to the outside world. Replies to requests you make already know where to be routed back to from information sent on the request.

If you are going to use your external IP behind a router, you will need to enable port forwarding.

Get LAN IPs for all interfaces on current computer:

    ifconfig | grep -B1 "inet addr" | awk '{ if ( $1 == "inet" ) { print $2 } else if ( $2 == "Link" ) { printf "%s:" ,$1 } }' | awk -F: '{ print $1 ": " $3 }'

Each interface has its own IP. Therefore, a single computer can have multiple LAN IPs: one for the wired connection, one for the Wiki, one loopback localhost, etc.

The server on the router is called **proxy server**.

Internal IPs may be assigned automatically via the DHPC protocol.

###Port forwarding

By default, if a TCP / UDP SYN request is made to most routers, they are simply dropped.

This means that you cannot serve a web server from behind the router.

To avoid this, you must set up *port forwarding*, that specifies certain ports and protocol (TCP or UDP) that will be sent to a local LAN IP.

It seems only possible to do this if the local IP is static TODO confirm.

###Subnet mask

####Get mask for an interface:

    ifconfig wlan0 | sed -nr 's/.*Mask:([^ ]*)/\1/p'

Internal IPs have two parts: network and computer.

The length of the network part may vary between networks.

The length is given by the **subnet mask**, e.g.:

    255.255.255.0
    1111.1111.1111.0000

means that 12 first bits are network.

    255.255.0.0

means that 8 first bits are network

All computers in the same network must have the same subnet mask and the same network part, but different computer parts.

Each network (formally **network segment**) is run by a single router #TODO confirm

###Special addresses

####Zero host address

<http://serverfault.com/questions/135267/what-is-the-network-address-x-x-x-0-used-for>

If the entire host part is zero, then the address is used to refer to the network itself.

It is used when several networks, one one a different router must speak to each other.

###Default gateway

`0.0.0.0` network address in the routing table.

If no network matches request, sends to this network.

Address you get automatically redirected to by router if the address you gave cannot be found on the local network.

Find default gateway:

    route -n

or for programmatic usage:

    route -n | awk '{ if( $1 ~ "0.0.0.0" ) print $2 }'

###Broadcast address

The host address is entirely composed of 1s.

The broadcast address means talking to all computers on a given network at once instead of a single computer

####Examples

#####Class C network

-   network part: `192.168.3`

    Broadcast is: `192.168.3.255`

-   network part: `192.168.234`

    Broadcast is: `192.168.3.255`

#####Class A network

- network part: `10`

    Broadcast is: `10.255.255.255`

###.1 addresses

The `.1` address is not special, but in home networks is often already taken by the router's inner interface

This is why your addresses may start at `.2`.

##NIC

Network Interface Cards

Hardware that does network communication.

Come mostly built-in the motherboard today.

Each router has at least 2 NICs: one external and one internal.

###get all interface names

    ifconfig | perl -ne '/^(\S+)/ && print $1 . "\n"'

##MAC

AKA:

- physical address
- hardware address
- media access control address
- BIA: burnt in address

Unchangeable address of each NIC.

Unique across and within vendors.

6 bytes: first 3 identify vendor, last 3 product

Colon separated notation. Ex: `0C:21:B8:47:5F:96`.

Get MAC addresses of my computer:

    ifconfig

Or for programmatic usage:

    ifconfig | sed -nr 's/([^ ]*) .*HWaddr (.*)/\1 \2/p'

Get MAC addresses of computers I have already talked to in the LAN:

    timeout 3 ping 192.168.1.3
    arp -a | sed -nr 's/([^ ]*) .*at (.*)/\1 \2/p'

#TCP vs UDP

Different protocols

TCP guarantees that information packages arrive, UDP does not.

For that, TCP has to maintain a connection, while UDP simply sends the packages and hopes for the best.

For this reason, UDP has less overhead, but is only used when the transaction will limit itself to a single request/answer.

Some protocols include both a TCP and a UDP version, which may vary slightly while others only have either a TCP or an UDP version see <http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers> for a listcounting acknowledge packages.

##TCP

Learn the TCP header:

<http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure>

##ICMP

Internet control message protocol.

Protocol that is part of the IP protocol.

Contains several types of information for routers about the IP traffic.

Lives in the Internet layer, but is encapsulated inside an IP datagram just like TCP and UDP:

    | ICMP data |
    | IP data   | IP header |

Its number on the IP protocol field is 1, so you may guess that this is a very important protocol.

Structure of the ICMP header

    - Type 1B
    - Code 1B
    - Checksum 2B
    - Variable part 4B

ICMP can also contain an optional extra data section after the variable part.

Examples of what ICMP can do:

-   ECHO requests.

    The server responds with another echo request with the same data.

    Used to testing the network.

    Used by the ping utility.

-   destination unreachable

    Datagram cannot be transmitted further by a router.

    TODO when does this happens? This is not the `TTL = 0` since that is covered by Time Exceeded

-   source quench

    Router tells source to lower sending speed because the network is too overloaded.

-   redirect

    Router tells source to not make that request again, since there is an obvious better choice of router to make the request to.

    Typically happens on a LAN with 2 routers, if a host sends a request to a bad router.

-   router discovery

    Source asks for any routers on the LAN to identify themselves.

-   time exceeded.

    -   if `code = 0`: TTL reached 0.

        Router notifies source of that via ICMP.

        Used by `traceroute`.

    -   if `code = 1`: reassembly time exceeded.

        IP headers can be fragmented.

        If the first part reaches, but the second takes too long, the reciever discards the first to make room for other requests, and notifies the source like this.

-   packet too big (BTP)

    Sent by router to source if it receives a packet that is larger than the MTU and the IP header has `DF = 1`.

##IGMP

Internet Group Message Protocol.

Similar to ICMP in some senses:

- wrapped inside IP
- IP control purposes

However IGMP is used to control multicasts only.

IP protocol number: 2.

#ping

CLI utility that sends ICMP echo requests to a server that accepts them.

It measures the time it takes for the answer to come back, which is a measure of connectivity between the two computers.

It is often used in online games.

The default IANA port for ping requests is port 7/TCP or 7/UDP.

Send an echo every second to monitor connectivity:

    ping www.google.com

#traceroute

CLI utility that shows each step an IP package takes to reach a destination.

Operation is simple: the program sends the request with TTL = 1, TTL = 2, TTL = 3, and so on, and gets the address at which it stopped via ICMP time exceeded router responses.

Example:

    traceroute www.google.com

#tcpdump

CLI utility that allows to visualize TCP packets sent and received.

Good intro tutorial: <http://danielmiessler.com/study/tcpdump/>

Also consider Wireshark, whose output is generally easier to interpret (but unfortunately is a X GUI instead of CLI).

Most useful options:

-   `-X`: show ASCII and hex side by side:
-   `-n`: don't resolve hostnames, show numeric IPs
-   `-S`: don't resolve hostnames, show numeric IPs
-   `-vvv`: maximum verbosity level

    Interprets standard data types and prints them, making output easier to understand.

Example:

    sudo tcpdump -SXn

#tcpflow

Show data send and read at a given port.

Easy to read output.

<http://superuser.com/questions/23180/whats-the-easiest-way-to-sniff-tcp-traffic-data-on-linux>

Ubuntu 12.04 install:

    sudo aptitude install tcpflow

Sample usage:

    sudo tcpflow -i any -C -e port 1234

#Wireshark

Set of utilities that that capture (snif) TCP IP packages similarly to `tcpdump`.

Analyzes packages if possible, and presents them on a human readable way. For this reason this is an amazing tool to really understand everything that goes on your computer's network interfaces.

Open source and cross platform (Linux and Windows).

#netrc

`$HOME/.netrc` is a config file that automates net logins (TODO: which type exactly of login?)

E.g.:

    machine code.google.com login <login> password <pass>

#host

A host is anything able to send and receive packages over a network: this includes workstations (computers) and routers.

Can be specified by either

- an IP
- a string that will be resolved by a DNS server to an IP

##host user pair

A user may access a (system) computer from another computer using for example ssh.

To do so, he must be registered in the target computer.

This is why user/host pairs are common: the host pair says from which computer user is trying to access his account.

#hostname

An alias for an IP, local or remote.

Must be converted into an IP via DNS.

When outside the local network, the hostname is added before the domain name, e.g. in:

    www.google.com

- hostname: `www`
- domain name: `google.com`

It is not a good idea to have a dot `.` in your domain name, since then how could its last part be distinguished from the domain name?

TODO is the hostname `www.google.com` or just `google.com`? Contradictory answers: <http://superuser.com/questions/59093/difference-between-host-name-and-domain-name>

##www

`www.google.com` and `google.com` can lead to different IPs.

What sane companies do is choose one and redirect the other, *be consistent*.

But beware: I have seen companies that use `www` for a different website than without, and it is possible that no redirection happens.

Beware that browsers can store different cookies for both, so you can be logged in at `www.a.com` but not at `a.com`.

It is more recommended today not to use the `www` because it is what the huge majority of users wants on a website: <http://stackoverflow.com/questions/1109356/www-or-not-www-what-to-choose-as-primary-site-name>. `www` implies that we are using `HTTP`, but we already have the HTTP part of the URL.

In the case of FTP, `ftp://ftp.a.com` URLs which are common, and perhaps in that case it is better to keep the `ftp` and redirect HTTP requests to `ftp.a.com` to `ftp://ftp.a.com` since FTP is less used than HTTP, allowing users to type simply `ftp.a.com` instead of `ftp://a.com`.

`www` was more used in the past, so older companies may continue to use them because they are stuck with it.

As of early 2014:

- `facebook.com` redirects to `www.facebook.com`
- `google.com` redirects to `www.google.com`

##localhost

Host that refers to the computer itself, specially for testing purposes.

Corresponds to a virtual device called the loopback interface.

#Domain name

E.g.: `google.com`, `stackoverflow.com` are commonly called domain names.

A more precise way of speaking is saying that `google` is a subdomain of `com`, and `www` is a subdomain of `google.com`.

They identify a network owned by Google. But in order to get an actual IP, you still need to add a hostname such as `www`.

Domain names may contain more than one `.`: `bbc.co.uk`.

##Subdomain

The subdomain can include a period (.) but not as the first or last character. Consecutive periods (...) are not allowed. A subdomain cannot exceed 25 characters.

##example.com

<http://example.com> is a test domain reserved by IANA.

It is a serves as a great URL placeholder on simple examples.

#Top level domain

`.com`, `.net`, `.io`, `.fr` are examples.

Every name must be under one of those.

They are controlled by IANA, and there are not that many out there
except for the country ones: <http://en.wikipedia.org/wiki/List_of_Internet_top-level_domains>

To get a country TLD, it seems that you must have some link with the country.

Some TLDs are reserved for certain uses and registrars must check that you/ your organization
are eligible: `.gov` for governments, `.mit` for US military.

Some interesting ones:

- `.sexy` and `.xxx`. Guess what.
- `.guru`. No suggested use. Funny.

Some country ones have become generic: `.io` is a notable example,
popular amongst startups as of 2014-03. Short, sounds good, reminds of IO input output.

#DHCP

Dynamic Host Configuration Protocol.

<http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol>

Application layer protocol that automatically assigns configurations to the hosts on a network, such as their IP.

Default IANA ports: UDP 67 and 68 (same as its less advanced and less common predecessor `BOOTP`).

When a computer enters a network and it does not know its own IP.

It must first send a DHCP request to be assigned an IP.

The server usually (TODO always?) runs in the router, and can be configured from the router's interface.

#Static IP

On a home network that you control, it is better to use intuitive hostnames
and let the addresses be dynamically set via DHPC, unless you absolutely need a static IP,
for example to setup a server behind your router.

DHPC does not know about static IPs: if you set one you must make sure
that it is outside of the DHPC range. DHPC is done by the router,
and should be configurable from the browser interface.

On my Numericable router, under Network > Basic Settings > IP LAN > I have two fields:
`Starting IP Address` and `Ending IP Address` which allow me to control it.
By default, the range is 192.168.0.10 to 192.168.0.50, which is a sensible default
allowing for 8 small static IPs between 2 and 9, 1 being the router's address.

On Ubuntu 12.04, there are a few ways of doing it.

##Static IP with DHCP reservation

This is not strictly static, but it is the simplest option.

On you router configuration, find the DHCP Reservation Lease Infos.

This allows you to map LAN IPs directly to MAC addresses.

On my Numericable router it is found under the IP LAN tab.

Set the interface to use DHCP.

The assigned address must be in the DHCP range.

##Static IP with NetworkManager

Using the NetworkManager GUI:

    nm-connection-editor

Select connection > Edit > IPv4 settings, configure.

TODO fails. I lose internet connection on the interface

##Static IP with NetworkManager

Using `/etc/network/interfaces`:

    sudo vim /etc/network/interfaces

Set the file to:

    auto lo
    iface lo inet loopback

    auto eth0
    iface eth0 inet static
    address 192.168.0.2
    netmask 255.255.255.0
    gateway 192.168.0.1
    dns-nameservers 89.2.0.1
    dns-search example.com
    #network 192.168.0.0

- `auto if1 if2`: automatically create interfaces `if1` and `if2` on `ifup -a`.
- `iface if1`: from now on, define properties of `if1`.

TODO fails. I lose internet connection on the interface

#hosts file

Located at:

    /etc/hosts

Tells your computer where to redirect the given names.

Takes precedence over DNS.

Big downside: you have to have one of this file on every PC.

Therefore, use a DNS server instead

    cat /etc/hosts

Redirect Wikipiedia to localhost:

    echo "127.0.0.1 www.wikipedia.org" | sudo -a /etc/hosts

Now:

    firefox www.wikipedia.org &

will go to localhost, and you will see your Apache page if you are running apache.

Undo that, its silly:

    sudo sed -i "$ d" /etc/hosts

##windows

The file is:

    C:\Windows\System32\Drivers\Etc\hosts

#DNS

Domain Name System.

Part of the application layer.

Standard IANA port: 53/UDP

Protocol that convert strings into IPs, for example:

    http://www.google.com -> 173.194.34.34

Before before using an address such as `www.google.com`,
any program such as a browser must first resolve the hostname `www.google.com`
into an IP by asking that from a server.

Linux systems usually offer `man resolver` C library interface,
which any program can use to resolve DNS names.
The resolver library may cache results across applications that have already been resolved.

##DNS on WAN

On the Internet, hostnames are resolved to IPs by DNS servers.

You must pay to reserve hostnames so they can be resolved to the IP of your choice.

TODO how to DNS servers find out all the hostnames in the world?

##DNS on LAN

DNS can also be done for local networks:

    computer2 -> 192.168.0.3

In which case the DNS server normally resides on the router.

Client computers on the network are informed that it is a DNS server via DHCP.

On your LAN, people can use the host name to communicate between computers

For example, John is running an Apache server on the usual port 80. He has hostname `john`.

Mary is on the same network. Therefore, she can refer to `john` simply as `john`. For example:

    ping john
    firefox john

TODO if many people set up the same hostname, then what?

##host utility

Get IP for a given hostname:

    host www.google.com

Sample output:

    173.194.78.105

##resolv.conf

    cat /etc/resolv.conf

Lists DNS servers.

This file may be automatically generated by utilities.

On Ubuntu 12.04, you should never edit that file manually. By default it contains:

    nameserver 127.0.1.1

which is localhost, and is used indirectly by the NetworkManger system, which you should use instead.

##hostname utility

Print currently desired hostname:

    echo $HOSTNAME
    hostname

In the default bash `PS1` line for Ubuntu and many systems you see:
`ciro@ciro-Thinkpad-T430`, then the hostname is `ciro-Thinkpad-T430`.

Change hostname for cur session:

    h=
    sudo hostname "$h"

prompt `PS1` is not changed immediately.

##Change hostname permanently

    h=
    echo "$h" | sudo tee /etc/hostname

###Windows

Host is referred to as "computer name". Good name choice, that is exactly what host is.

    wmic computersystem where name="%COMPUTERNAME%" call rename name="NEW-NAME"

##Reverse DNS

Protocol that transforms an IP into a hostname.

Not always supported on all DNS servers.

##dig

CLI utility that shows complete path of domain to IP resolution, as it passes through multiple CNAMEs.

TODO

##Zone file

When you register for a domain of your own, you will start thinking about this:
it is the main setting on your registrar interface.

<http://en.wikipedia.org/wiki/Zone_file>

###apex domain

`@` in the zone file means the domain you own without any subdomain.

E.g., if you own `cirosantilli.com`, `@` means `cirosantilli.com` itself,
while `www` means `www.cirosantilli.com`.

Apex domains are more restrictive than subdomains,
and certain hosting services advise against it, such as GitHub Pages.

The main problem is that in services such as GitHub pages you don't get an actual IP,
so you can't point the Apex to an IP (which is simple),
and the `CNAME` "workaround" is not good enough in that case.

###naked domain

The apex domain is sometimes called naked domain, since it has no subdomain.

##CNAME record

TODO File that tells DNS to redirect to another domain name, creating an alias.

<http://en.wikipedia.org/wiki/CNAME_record>

##A

Points a domain to an IP. The final part of the resolution.

##DDNS

Dynamic DNS.

A way to update DNS as IPs change.

Useful for example if you want to give a hostname for your home network,
in which the IP is dynamic for most ISPs.
A DDNS service like <http://www.noip.com> can give you a persistent hostname anyways.

TODO what is it exactly? How does it work? A protocol? Part of DNS?

#Port

Once you have determined a host (computer), you still have to talk to one of the specific programs
running on that computer.

Each program listens on an specific port which is set by convention.

Ports from 1 - 1023 are also known as "well-known ports" or "privileged ports".
On UNIX-like systems, only privileged users (`root`) can bind to those ports.
All have reserved or standardized functions by an organization called IANA:
<http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>.

The ports form 1024 to 49151 are the so called "registered ports".
Projects can make a request to IANA to register one of those posts
as used in order to avoid port clashes.
On most systems, it is possible to bind to those ports without `sudo`.

There are 2 ports number 10: `10/tcp` and `10/udp`, each for a different protocol.

On POSIX systems, ports are typically implemented via sockets.

##Read and write to a port from the command line

You can write to a port in many ways using the command line.

#Router

Routers send packages from one place to another.

Most routers will have at least two network interfaces, one on each network.

##Configure you router

If you want to play around with routers, you should get your hands dirty and do some router configuring.

Routers are generally configured through a browser.

First you must make a wired connection to the router.

You must enter the IP address of your router. This is fixed and supplied by the router manufacturer.
A common address is the first address of the range: `192.168.0.1` for class C.

You must then enter a username and a password. A default will be supplied by the manufacturer,
such as `admin` `admin`, or `admin` `password`. This can be changed once you logged in.

##Routing table

Great LAN routing example: <http://en.wikipedia.org/wiki/Default_gateway>

Routing tables say: if the request should go to a given network, send it to a given interface.

`0.0.0.0` is the default if no other is found.

Routers have two interfaces each: inside and outside.

#ARP

Address Resolution Protocol.

Only used when the sender detects that the searched IP is on the same network as itself.

In that case, it can simply get the destination MAC address and send the packages over the LAN
directly to the destination without passing through the router.

ARP is a protocol that does just that: it finds the MAC address from an IP on a LAN.

##ARP table

Cache that caches previously resolved IP to MAC addresses so that ARP requests don't need to be made every time.

Also known as: ARP cache, MAC cache.

##arp utility

CLI utility that shows the ARP table.

To see a computer on the table, remember that you first must have tried to contact it somehow,
so first ping that computer:

    timeout 3 ping 192.168.1.3; arp -a

#route utility

View kernel routing table:

    route

Numeric instead of names:

    route -n

#whois

Check info about IP, country, ISP:

    whois 201.81.160.156

    whois `curl ifconfig.me`

#Network management tools

There are several levels of network management tools:
<http://askubuntu.com/questions/1786/what-is-the-difference-between-network-manager-and-ifconfig-ifup-etc>.

From the lowest level to the highest:

- `ifconfig`
- `ifup` and `ifdown`
- NetworkManager

#ifconfig

Network InterFace configuration tool.

Includes stuff like IPs, subnet masks, MAC, etc.

Good source: <http://www.thegeekstuff.com/2009/03/ifconfig-7-examples-to-configure-network-interface/>

    ifconfig

Sample interfaces on a modern laptop:

- `eth0`:  wired network 0
- `wlan0`: Wifi card 0
- `lo`:    loopback (local host)

Get local IPs (behind router):

    ifconfig | grep -B1 "inet addr" | awk '{ if ( $1 == "inet" ) { print $2 } else if ( $2 == "Link" ) { printf "%s:" ,$1 } }' | awk -F: '{ print $1 ": " $3 }'

`wlan0` and `eth0` are two different interfaces!

#iwconfig

Wireless network configuration

#ifup

#ifdown

TODO

##/etc/network/interfaces

Configuration for `ifup` and `ifdown`.

    man interfaces

If you manually set configuration on `/etc/network/interfaces`,
NetworkManager will now touch those interfaces and display them as "Not Managed".

#NetworkManager

GNOME project for simplifying network configuration. <https://wiki.gnome.org/Projects/NetworkManager>

Also has an Applet that shows on Ubuntu 12.04's taskbar, indicating connection status.

On Ubuntu it comes on the packages `network-manager` and `network-manager-gui` for the applet.

It corresponds to the upstart service `network-manager`,
so for example to reload configurations it can be restarted with:

    sudo service network-manager restart

##nm-applet

The applet.

##nm-connection-editor

Opened from the applet "Edit Connections".

##nm-tool

Get NetworkManager status from the command line. Sample output:

    NetworkManager Tool

    State: connected (global)

    - Device: wlan0  [NUMERICABLE-B2BD] --------------------------------------------
    Type:              802.11 WiFi
    Driver:            rtl8192ce
    State:             connected
    Default:           no
    HW Address:        E0:06:E6:C7:97:8F

    Capabilities:
        Speed:           72 Mb/s

    Wireless Properties
        WEP Encryption:  yes
        WPA Encryption:  yes
        WPA2 Encryption: yes

    Wireless Access Points (* = current AP)
        NUMERICABLE-4D5F:Infra, C0:D9:62:C7:43:49, Freq 2412 MHz, Rate 54 Mb/s, Strength 26 WPA WPA2
        FREEBOX_BRAHIM_GH: Infra, F4:CA:E5:D9:B3:2C, Freq 2437 MHz, Rate 54 Mb/s, Strength 26 WPA
        Jordy:           Infra, 56:76:06:1D:11:14, Freq 2442 MHz, Rate 54 Mb/s, Strength 26 WPA
        *NUMERICABLE-B2BD: Infra, E0:AB:31:AC:30:6D, Freq 2412 MHz, Rate 54 Mb/s, Strength 84 WPA WPA2
        freephonie:      Infra, 56:76:06:1D:11:17, Freq 2442 MHz, Rate 54 Mb/s, Strength 26 WPA Enterprise
        NUMERICABLE-F1EC:Infra, 00:1A:2B:9B:0C:F4, Freq 2462 MHz, Rate 54 Mb/s, Strength 26 WPA WPA2
        [...]

    IPv4 Settings:
        Address:         192.168.0.10
        Prefix:          24 (255.255.255.0)
        Gateway:         192.168.0.1

        DNS:             89.2.0.1
        DNS:             89.2.0.2


    - Device: eth0  [Wired connection 1] -------------------------------------------
    Type:              Wired
    Driver:            e1000e
    State:             connected
    Default:           yes
    HW Address:        00:21:CC:CE:F2:C1

    Capabilities:
        Carrier Detect:  yes
        Speed:           1000 Mb/s

    Wired Properties
        Carrier:         on

    IPv4 Settings:
        Address:         192.168.0.11
        Prefix:          24 (255.255.255.0)
        Gateway:         192.168.0.1

        DNS:             89.2.0.1
        DNS:             89.2.0.2

##nmcli

Control NetworkManger from CLI.

Bring down wired connection:

    nmcli con down id 'Wired connection 1'
    nmcli dev disconnect iface eth0

Bring it back up:

    nmcli con up id 'Wired connection 1'

##/etc/NetworkManager/system-connections/NUMERICABLE-B2BD

##configuration file

NetworkManager's configuration files:

    sudo vim /etc/NetworkManager/system-connections/ID

one per interface.

Modified through the applet.

#MTU

<http://en.wikipedia.org/wiki/Maximum_transmission_unit>

Maximum transmission unit.

Maximum packet size that can be transmitted over a physical link.

Varies across different link technologies.

#nmap

Show open ports, state and service name associated to the port.

Ubuntu 12.04 install:

    sudo aptitude install nmap

TCP services:

    nmap google.com
    nmap localhost

You are gonna get at least 80 on Google for their HTTP server and on localhost too if you are running an HTTP server such as apache.

sample output excerpt:

    PORT     STATE SERVICE
    80/tcp   open  http

TODO understand STATE and where SERVICE comes from

View UDP ports:

    sudo nmap -sU localhost

#netstat

Shows lots of POSIX sockets info.

Get list PID and program name of programs using ports.

Shows both TCP/UDP Internet connections and UNIX domain sockets.

In short: Internet connections are done via sockets whose address is given by an IP and a port number,
and can communicate across computers

UNIX domain sockets are only for local communication.
They are put into the filesystem and identified by a path on the filesystem

When a program uses a socket, it binds to it, and other programs cannot use it.

Most useful options:

- `n`: don't resolve IPs into hostnames. Greatly speeds up the output generation.
- `a`: show both listening and not listening ports.
- `p`: show program name and PID.
- `t`: show only TCP
- `u`: show only UDP
- `x`: show only UNIX sockets
- `i`: show information on interfaces.
- `r`: show kernel routing table.
- `s`: show statistics on several protocols.

Sample output for Internet section:

    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 localhost:32842         localhost:48553         ESTABLISHED 3497/GoogleTalkPlug

#Telnet

Protocol for communicating between servers and name of command line tool that uses it.

No encryption, therefore *DONT'T SEND PASSWORDS ON UNTRUSTED NETWORK WITH THIS*!

Always use ssh which is encrypted for anything even remotely serious.

The other computer must be running a telnet server.

Fun MUD games!.

Make HTTP requests by hand for learning purposes:

    telnet google.com 80

Type:

    GET / HTTP/1.0 <enter><enter>

You've made a get request by hand!

TODO won't work, why? How to programmatically write characters on a request?

    echo $'GET / HTTP/1.0\n\n' | telnet www.google.com 80

also consider:

- `nc`
- `socat`

#Samba

Open source Linux implementation of the SMB/CIFS networking protocol used by default on Windows.

It allows for file, printer and driver sharing on a network.

Best option for cross platform file transfers.

#Browser

##Firefox

Search with default engine:

    firefox -search asdf

Starts with disabled extensions in case they are causing a crash:

    firefox -safe-mode

##Chrome

Some websites run neither on Firefox nor Chromium, only Chrome.

To have multiple chrome profiles do:

##w3m

ncurses web browser!

Might save you if X goes down or if you can't have it.

#Files

TODO

##/etc/protocols

##/etc/services

##/etc/udev/rules.d/70-persistent-net.rules

#Deployment

##Zymic

Free PHP.

Did not work well with WordPress, probably some PHP restrictions.

##000

Worked for WordPress.

##OpenShift

Open source.

Operated as service by Red Hat.

SSH access.

Languages: Python, Java, Ruby.

Lots of templates, including wordpress.

Number of apps quite limited: 3 per account.

Console local client:

    sudo gem install rhc

Start app (apps are stopped by default):

    sudo gem install rhc

#VPN

TODO get working

Control another computer with you computer.

Unless the other computer says who you are, It is impossible to tell that you are not the other computer

Several protocols exist.

    sudo aptitude install network-manager-openvpn network-manager-openvpn-gnome

Servers:

- <http://www.vpnbook.com/#pricing>

#TLS

Transport Layer Security.

Encryption methods that encrypt the transport layer traffic.

#SSL

Predecessor of TLS.

#Web server vs app server

It is hard to distinguish them.

Generally, web server only speaks HTTP and serves static pages.

An app server, reads the HTTP, and then decides to pass the request on to a programming language
like Ruby or Python if it cannot deal with it himself through an interface such as CGI.

In most production environments, the server knows which files it can serve directly
without going through a script, making thing faster.

Applications like Apache and Nginx.
